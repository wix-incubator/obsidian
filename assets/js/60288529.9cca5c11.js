"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[6193],{1184:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>c});var t=o(4041);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},6489:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"documentation/usage/Hooks","title":"Hooks","description":"Injecting hooks","source":"@site/docs/documentation/usage/Hooks.mdx","sourceDirName":"documentation/usage","slug":"/documentation/usage/Hooks","permalink":"/obsidian/docs/documentation/usage/Hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/usage/Hooks.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs2","previous":{"title":"Graphs","permalink":"/obsidian/docs/documentation/usage/Graphs"},"next":{"title":"Functional components","permalink":"/obsidian/docs/documentation/usage/FunctionalComponents"}}');var i=o(1085),s=o(1184);const r={sidebar_position:2},c=void 0,a={},d=[{value:"Injecting hooks",id:"injecting-hooks",level:2},{value:"Strongly typed hooks",id:"strongly-typed-hooks",level:2},{value:"Combining injected dependencies and required arguments",id:"combining-injected-dependencies-and-required-arguments",level:3},{value:"Typing the return value of a hook",id:"typing-the-return-value-of-a-hook",level:3}];function p(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"injecting-hooks",children:"Injecting hooks"}),"\n",(0,i.jsx)(n.p,{children:"Hooks are a fundamental construct in React. They allow you to plug into the lifecycle of a component or react to user interaction and execute code accordingly. As such, hooks typically need to interact with services where the actual logic is implemented."}),"\n",(0,i.jsxs)(n.p,{children:["Injecting hooks is simple and straightforward. Simply wrap your hook with the ",(0,i.jsx)(n.code,{children:"injectHook"})," function and declare any required dependencies as destructured properties."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\nconst myHook = ({fooService, barService}: Props) => {\n  // do something with fooService and barService\n}\n\ntype Props = DependenciesOf<ApplicationGraph, 'fooService' | 'barService'>; // {fooService: FooService, barService: BarService}\n\nexport injectHook(myHook, ApplicationGraph);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"strongly-typed-hooks",children:"Strongly typed hooks"}),"\n",(0,i.jsx)(n.p,{children:"Writing strongly typed hooks is important to ensure that your hooks are easy to use and that you don't accidentally break them when refactoring."}),"\n",(0,i.jsx)(n.h3,{id:"combining-injected-dependencies-and-required-arguments",children:"Combining injected dependencies and required arguments"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you want to inject hooks with dependencies, but also require additional arguments that will be passed from the calling scope. This is possible by using the ",(0,i.jsx)(n.code,{children:"injectHookWithArguments"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\ntype Injected = DependenciesOf<ApplicationGraph, 'fooService'>; // {fooService: FooService}\ntype Own = {count: number};\n\nconst myHook = ({fooService, count}: Injected & Own) => {\n  // do something with fooService and count\n}\n\nexport default injectHookWithArguments<Injected, Own>(myHook, ApplicationGraph);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"myHook"}),", we must pass the ",(0,i.jsx)(n.code,{children:"count"})," argument otherwise we will get a type error. ",(0,i.jsx)(n.code,{children:"fooService"}),", on the other hand, is optional and will be injected from the graph unless passed explicitly."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import myHook from './myHook';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(1337);\n  myHook({count}); \n  \n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"typing-the-return-value-of-a-hook",children:"Typing the return value of a hook"}),"\n",(0,i.jsxs)(n.p,{children:["When using the standard ",(0,i.jsx)(n.code,{children:"injectHook"})," function, the return value of the hook is inferred automatically by TypeScript. However, when using ",(0,i.jsx)(n.code,{children:"injectHookWithArguments"}),", due to limitations of TypeScript's Generics system, the return value is not inferred and you'll have to specify it explicity."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\ntype Injected = DependenciesOf<ApplicationGraph, 'fooService'>;\ntype Own = {count: number};\ntype Result: {onPress: () => void};\n\nconst myHook = ({fooService, count}: Injected & Own): Result => {\n  const onPress = useCallback(() => {\n    fooService.doSomething(count);\n  }, [fooService, count]);\n  return {onPress};\n}\n\nexport default injectHookWithArguments<Injected, Own, Result>(myHook, ApplicationGraph);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now the onPress callback is typed correctly when using the injected hook."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import myHook from './myHook';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(1337);\n  const {onPress} = myHook({count});\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);