"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2616],{1654:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var r=n(1085),a=n(1184);const t={sidebar_position:2,title:"MediatorObservable"},i=void 0,o={id:"reference/mediatorObservable",title:"MediatorObservable",description:"MediatorObservable is a type of Observable that acts as an adapter between one or more source Observables. It allows us to create a new observable stream based on the values of other observables.",source:"@site/docs/reference/mediatorObservable.mdx",sourceDirName:"reference",slug:"/reference/mediatorObservable",permalink:"/obsidian/docs/reference/mediatorObservable",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/reference/mediatorObservable.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"MediatorObservable"},sidebar:"reference",previous:{title:"Observable",permalink:"/obsidian/docs/reference/observable"},next:{title:"useObserver",permalink:"/obsidian/docs/reference/useObserver"}},l={},c=[{value:"Reference",id:"reference",level:2},{value:"new MediatorObservable(initialValue?)",id:"new-mediatorobservableinitialvalue",level:3},{value:"Arguments",id:"arguments",level:4},{value:"Caveats",id:"caveats",level:4},{value:"addSource(source, onNext): this",id:"addsourcesource-onnext-this",level:3},{value:"Arguments",id:"arguments-1",level:4},{value:"Returns",id:"returns",level:4},{value:"mapSource(source, mapNext): this",id:"mapsourcesource-mapnext-this",level:3},{value:"Arguments",id:"arguments-2",level:4},{value:"Returns",id:"returns-1",level:4},{value:"addSources(sources, onNext): this",id:"addsourcessources-onnext-this",level:3},{value:"Arguments",id:"arguments-3",level:4},{value:"Returns",id:"returns-2",level:4},{value:"mapSources(sources, mapNext): this",id:"mapsourcessources-mapnext-this",level:3},{value:"Arguments",id:"arguments-4",level:4},{value:"Returns",id:"returns-3",level:4},{value:"async first&lt;T&gt;(): Promise&lt;T&gt;",id:"async-firstt-promiset",level:3},{value:"Usage",id:"usage",level:2},{value:"Observing multiple sources",id:"observing-multiple-sources",level:3},{value:"Conditional rendering of a component",id:"conditional-rendering-of-a-component",level:3}];function d(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"MediatorObservable"})," ",(0,r.jsx)(s.strong,{children:"is a type of"})," ",(0,r.jsx)(s.code,{children:"Observable"})," ",(0,r.jsx)(s.strong,{children:"that acts as an adapter between one or more source"})," ",(0,r.jsx)(s.code,{children:"Observable"}),(0,r.jsx)(s.strong,{children:"s. It allows us to create a new observable stream based on the values of other observables."})]}),"\n",(0,r.jsxs)(s.p,{children:["For example, we can create a ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," that observes an Observable of a certain type and emits a new value based on the value of the source observable."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const user = new Observable<User>();\n\nconst isLoggedIn = new MediatorObservable<boolean>();\nisLoggedIn.add(user, (nextUser) => isLoggedIn.value = nextUser !== undefined);\n"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"#reference",children:"Reference"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#new-mediatorobservableinitialvalue",children:"new MediatorObservable(initialValue?)"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#addsourcesource-onnext-this",children:"addSource(source, onNext): this"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#mapsourcesource-mapnext-this",children:"mapSource(source, mapNext): this"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#addsourcessources-onnext-this",children:"addSources(sources, onNext): this"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#mapsourcessources-mapnext-this",children:"mapSources(sources, mapNext): this"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#async-firstt-promiset",children:"async first<T>(): Promise<T>"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"#usage",children:"Usage"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#observing-multiple-sources",children:"Observing multiple sources"})}),"\n",(0,r.jsx)(s.li,{children:(0,r.jsx)(s.a,{href:"#conditional-rendering-of-a-component",children:"Conditional rendering of a component"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(s.h3,{id:"new-mediatorobservableinitialvalue",children:"new MediatorObservable(initialValue?)"}),"\n",(0,r.jsxs)(s.p,{children:["Creates a new ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," with an optional initial value."]}),"\n",(0,r.jsx)(s.h4,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"initialValue?"})," - The initial value of the ",(0,r.jsx)(s.code,{children:"MediatorObservable"}),". Defaults to ",(0,r.jsx)(s.code,{children:"undefined"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"caveats",children:"Caveats"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["It's possible to instantiate a ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," without an initial value, but it's not recommended, as its value will be ",(0,r.jsx)(s.code,{children:"undefined"})," until it's set for the first time which can lead to unexpected behavior."]}),"\n"]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"addsourcesource-onnext-this",children:"addSource(source, onNext): this"}),"\n",(0,r.jsxs)(s.p,{children:["Starts observing the given source and calls the ",(0,r.jsx)(s.code,{children:"onNext"})," callback when the source emits a new value."]}),"\n",(0,r.jsx)(s.h4,{id:"arguments-1",children:"Arguments"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"source"})," - The source ",(0,r.jsx)(s.code,{children:"Observable"})," to observe."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onNext"})," - The callback to be called when the source emits a new value. The ",(0,r.jsx)(s.code,{children:"onNext"})," callback receives the new value of the source as an argument. ",(0,r.jsxs)(s.strong,{children:["In order to update the value of the ",(0,r.jsx)(s.code,{children:"MediatorObservable"}),", call the ",(0,r.jsx)(s.a,{href:"observable#set-value",children:"value setter"})," with the new value"]}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"addSource"})," returns the ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," instance, so it can be chained with other methods."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"mapsourcesource-mapnext-this",children:"mapSource(source, mapNext): this"}),"\n",(0,r.jsxs)(s.p,{children:["Starts observing the given source and calls the ",(0,r.jsx)(s.code,{children:"onNext"})," callback when the source emits a new value."]}),"\n",(0,r.jsx)(s.h4,{id:"arguments-2",children:"Arguments"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"source"})," - The source ",(0,r.jsx)(s.code,{children:"Observable"})," to observe."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mapNext"})," - The callback to be called when the source emits a new value. The ",(0,r.jsx)(s.code,{children:"mapNext"})," callback receives the new value of the source as an argument and ",(0,r.jsxs)(s.strong,{children:["must return the new value of the ",(0,r.jsx)(s.code,{children:"MediatorObservable"})]}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"returns-1",children:"Returns"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"mapSource"})," returns the ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," instance, so it can be chained with other methods."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"addsourcessources-onnext-this",children:"addSources(sources, onNext): this"}),"\n",(0,r.jsxs)(s.p,{children:["Similar to ",(0,r.jsx)(s.a,{href:"#addsourcesource-onnext-this",children:"addSource"}),", but accepts an array of sources instead of a single source. Use this method when the logic of the ",(0,r.jsx)(s.code,{children:"onNext"})," callback is the same for all sources."]}),"\n",(0,r.jsx)(s.h4,{id:"arguments-3",children:"Arguments"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sources"})," - An array of source ",(0,r.jsx)(s.code,{children:"Observable"}),"s to observe."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"onNext"})," - The callback to be called when any of the sources emits a new value. The ",(0,r.jsx)(s.code,{children:"onNext"})," callback receives the current values of all sources as arguments. In order to update the value of the ",(0,r.jsx)(s.code,{children:"MediatorObservable"}),", call the ",(0,r.jsx)(s.a,{href:"observable#set-value",children:"value setter"})," with the new value."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"returns-2",children:"Returns"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"addSources"})," returns the ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," instance, so it can be chained with other methods."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"mapsourcessources-mapnext-this",children:"mapSources(sources, mapNext): this"}),"\n",(0,r.jsxs)(s.p,{children:["Similar to ",(0,r.jsx)(s.a,{href:"#mapsourcesource-mapnext-this",children:"mapSource"}),", but accepts an array of sources instead of a single source. Use this method when the logic of the ",(0,r.jsx)(s.code,{children:"mapNext"})," callback is the same for all sources."]}),"\n",(0,r.jsx)(s.h4,{id:"arguments-4",children:"Arguments"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"sources"})," - An array of source ",(0,r.jsx)(s.code,{children:"Observable"}),"s to observe."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mapNext"})," - The callback to be called when any of the sources emits a new value. The ",(0,r.jsx)(s.code,{children:"mapNext"})," callback receives the current values of all sources as arguments and should return the new value of the ",(0,r.jsx)(s.code,{children:"MediatorObservable"}),"."]}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"returns-3",children:"Returns"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"mapSources"})," returns the ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," instance, so it can be chained with other methods."]}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsx)(s.h3,{id:"async-firstt-promiset",children:"async first<T>(): Promise<T>"}),"\n",(0,r.jsxs)(s.p,{children:["See ",(0,r.jsx)(s.a,{href:"observable#async-firstt-promiset",children:"Observable.first()"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(s.h3,{id:"observing-multiple-sources",children:"Observing multiple sources"}),"\n",(0,r.jsxs)(s.p,{children:["Sometimes data is computed from the values of other observables. We can use ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," to create a new observable that observes other observables and emits a new value based on their values."]}),"\n",(0,r.jsxs)(s.p,{children:["Let's walk through an example to see how this works. Say we're developing a live streaming app and want to change the quality of the stream based on the device's battery level and the network speed. We'll create two observables, ",(0,r.jsx)(s.code,{children:"batteryLevel"})," and ",(0,r.jsx)(s.code,{children:"networkSpeed"}),", and we'll merge their emissions in one new ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," called ",(0,r.jsx)(s.code,{children:"streamQuality"}),". By doing so, ",(0,r.jsx)(s.code,{children:"batteryLevel"})," and ",(0,r.jsx)(s.code,{children:"networkSpeed"})," will become the sources of the new ",(0,r.jsx)(s.code,{children:"MediatorObservable"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"enum NetworkSpeed { Poor = 150, Moderate = 550, Good = 2000 }\nenum streamQuality { Low, Medium, High }\n\nconst batteryLevel = new Observable<number>();\nconst networkSpeed = new Observable<number>();\n\n// Every time one of the sources emits a new value, the mediator will call the callback function\nconst streamQuality = new MediatorObservable<streamQuality>().mapSources(\n  [batteryLevel, networkSpeed],\n  (batteryLevel, networkSpeed) => {\n    if (batteryLevel < 15 || networkSpeed < NetworkSpeed.Poor) {\n      return streamQuality.Low;\n    }\n\n    if (networkSpeed < NetworkSpeed.Moderate) {\n      return StreamQuality.Medium;\n    }\n\n    return StreamQuality.High;\n  }\n);\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Now, every time the battery level or the network speed changes, the ",(0,r.jsx)(s.code,{children:"streamQuality"})," observable will emit a new value based on the new values of the sources."]}),"\n",(0,r.jsx)(s.h3,{id:"conditional-rendering-of-a-component",children:"Conditional rendering of a component"}),"\n",(0,r.jsxs)(s.p,{children:["When optimizing React applications for performance, avoiding unnecessary renders is one of the most important things to do. One way to do this is to use ",(0,r.jsx)(s.code,{children:"Observable"})," to conditionally render a component only when a certain condition is met. We can use ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," to create a new observable that observes another and emits a value only when a condition is met."]}),"\n",(0,r.jsxs)(s.p,{children:["To illustrate this, let's create a ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," that observes a user's score in a game. The ",(0,r.jsx)(s.code,{children:"MediatorObservable"})," will emit a new value when the user's score is greater than 10. We'll use this observable to conditionally render a component that displays a message when the user wins the game."]}),"\n",(0,r.jsx)(s.p,{children:"First, we'll declare the observables that we'll use:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-tsx",children:"// An observable that tracks a user's score in a game\nconst gameScoreObservable = new Observable<number>(0);\n\nconst isWinnerObservable = new MediatorObservable<boolean>(false)\n  .addSource(gameScoreObservable, (score) => {\n    if (score > 10) {\n      gameState.value = true;\n    }\n  });\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Now we can use the ",(0,r.jsx)(s.code,{children:"isWinnerObservable"})," to conditionally render the game's status:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-tsx",children:"const Game = () => {\n  const [isWinner] = useObserver(isWinnerObservable);\n\n  return (\n    <div>\n      {isWinner && <p>You won!</p>}\n      <GameBoard />\n    </div>\n  )\n}\n"})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1184:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var r=n(4041);const a={},t=r.createContext(a);function i(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);