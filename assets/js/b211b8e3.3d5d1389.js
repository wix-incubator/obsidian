"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[9467],{95:(e,n,r)=>{r.d(n,{A:()=>w});var t=r(4041),s=r(3640),a=r(5245),i=r(6090),o=r(3190),c=r(838),l=r(6423),d=r(3996);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:r}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:r,attributes:t,default:s}}=e;return{value:n,label:r,attributes:t,default:s}}))}(r);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function u(e){let{value:n,tabValues:r}=e;return r.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:r}=e;const s=(0,i.W6)(),a=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:n,groupId:r});return[(0,c.aZ)(a),(0,t.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function m(e){const{defaultValue:n,queryString:r=!1,groupId:s}=e,a=p(e),[i,c]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=r.find((e=>e.default))??r[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a}))),[l,h]=g({queryString:r,groupId:s}),[m,b]=function(e){let{groupId:n}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,a]=(0,d.Dv)(r);return[s,(0,t.useCallback)((e=>{r&&a.set(e)}),[r,a])]}({groupId:s}),f=(()=>{const e=l??m;return u({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{f&&c(f)}),[f]);return{selectedValue:i,selectValue:(0,t.useCallback)((e=>{if(!u({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),b(e)}),[h,b,a]),tabValues:a}}var b=r(1310);const f={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};var x=r(1085);function v(e){let{className:n,block:r,selectedValue:t,selectValue:i,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),d=e=>{const n=e.currentTarget,r=c.indexOf(n),s=o[r].value;s!==t&&(l(n),i(s))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=c.indexOf(e.currentTarget)+1;n=c[r]??c[0];break}case"ArrowLeft":{const r=c.indexOf(e.currentTarget)-1;n=c[r]??c[c.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":r},n),children:o.map((e=>{let{value:n,label:r,attributes:a}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{c.push(e)},onKeyDown:h,onClick:d,...a,className:(0,s.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":t===n}),children:r??n},n)}))})}function j(e){let{lazy:n,children:r,selectedValue:a}=e;const i=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function y(e){const n=m(e);return(0,x.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,x.jsx)(v,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function w(e){const n=(0,b.A)();return(0,x.jsx)(y,{...e,children:h(e.children)},String(n))}},1184:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(4041);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}},5781:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"documentation/usage/Graphs","title":"Graphs","description":"Introduction","source":"@site/docs/documentation/usage/Graphs.mdx","sourceDirName":"documentation/usage","slug":"/documentation/usage/Graphs","permalink":"/obsidian/docs/documentation/usage/Graphs","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/usage/Graphs.mdx","tags":[{"inline":true,"label":"Graph","permalink":"/obsidian/docs/tags/graph"},{"inline":true,"label":"Lifecycle-bound","permalink":"/obsidian/docs/tags/lifecycle-bound"}],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"tags":["Graph","Lifecycle-bound"]},"sidebar":"docs2","previous":{"title":"Usage","permalink":"/obsidian/docs/category/usage"},"next":{"title":"Hooks","permalink":"/obsidian/docs/documentation/usage/Hooks"}}');var s=r(1085),a=r(1184),i=r(95),o=r(6816);const c={sidebar_position:1,tags:["Graph","Lifecycle-bound"]},l=void 0,d={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Declaring dependencies in a graph",id:"declaring-dependencies-in-a-graph",level:2},{value:"Specifying relationships between dependencies",id:"specifying-relationships-between-dependencies",level:2},{value:"Graph types",id:"graph-types",level:2},{value:"The singleton graph",id:"the-singleton-graph",level:3},{value:"The lifecycle-bound graph",id:"the-lifecycle-bound-graph",level:3},{value:"Passing props to a lifecycle-bound graph",id:"passing-props-to-a-lifecycle-bound-graph",level:4},{value:"The lifecycle of a lifecycle-bound graph",id:"the-lifecycle-of-a-lifecycle-bound-graph",level:4},{value:"Graph composition",id:"graph-composition",level:2},{value:"Subgraphs",id:"subgraphs",level:3},{value:"Private subgraphs",id:"private-subgraphs",level:3},{value:"Use case",id:"use-case",level:4},{value:"Visibility rules",id:"visibility-rules",level:4},{value:"Abstract graphs",id:"abstract-graphs",level:3},{value:"Typed dependencies",id:"typed-dependencies",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"In Object Oriented Programming, programs are organized around objects, where each object has a specific purpose. These objects can require other objects to perform their responsibilities. The required objects are called dependencies. Providing these dependencies manually is a tedious and error-prone process. The dependency injection pattern is a way to automate this process so you can focus on the logic of your application instead of writing boilerplate code."}),"\n",(0,s.jsx)(n.p,{children:'Before you can inject dependencies into hooks, components and classes, the dependencies first need to be declared so Obsidian knows how to construct them. In Obsidian, dependencies are declared in classes called "Graphs". Graphs create a centralized place where dependencies are defined. This makes them a powerful tool for understanding the relationships between objects in your program.'}),"\n",(0,s.jsx)(n.h2,{id:"declaring-dependencies-in-a-graph",children:"Declaring dependencies in a graph"}),"\n",(0,s.jsxs)(n.p,{children:["The snippet below shows a basic example of a Graph. It defines two dependencies, ",(0,s.jsx)(n.code,{children:"httpClient"})," and ",(0,s.jsx)(n.code,{children:"databaseService"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="ApplicationGraph.ts"',children:"import {singleton, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@singleton() @graph()\nexport class ApplicationGraph extends ObjectGraph {\n  @provides()\n  httpClient(): HttpClient {\n    return new HttpClient();\n  }\n\n  @provides()\n  databaseService(): DatabaseService {\n    return new DatabaseService();\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Graphs must be annotated with the ",(0,s.jsx)(n.code,{children:"@graph"})," decorator. In this example we chose to annotate the class with the ",(0,s.jsx)(n.code,{children:"@singleton"})," decorator as well, which means that the graph and the dependencies it provides will only be constructed once."]}),"\n",(0,s.jsxs)(n.p,{children:["Dependencies are constructed in methods annotated with the ",(0,s.jsx)(n.code,{children:"@provides"})," annotation. The ",(0,s.jsx)(n.code,{children:"@provides"})," annotation is used to tell Obsidian that the method is a dependency provider. From now on we'll refer to these methods as providers. Obsidian uses the provider's method name as the dependency's name. In this example, the ",(0,s.jsx)(n.code,{children:"httpClient"})," provider method provides the ",(0,s.jsx)(n.code,{children:"httpClient"})," dependency. The ",(0,s.jsx)(n.code,{children:"databaseService"})," provider method provides the ",(0,s.jsx)(n.code,{children:"databaseService"})," dependency."]}),"\n",(0,s.jsx)(n.p,{children:"Once your graph is declared you can use it to inject dependencies into the various constructs that form your application:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/documentation/usage/Hooks#injecting-hooks",children:"Inject hooks"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/documentation/usage/FunctionalComponents",children:"Inject functional components"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/documentation/usage/ClassComponents",children:"Inject components"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/documentation/usage/Classes",children:"Inject classes"})}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Did you know?",type:"info",children:(0,s.jsxs)(n.p,{children:['The term "graph" comes from ',(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Graph_theory",children:"graph theory"}),". Obsidian constructs ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Directed_acyclic_graph",children:"Directed Acyclic Graphs"})," (DAGs) to represent the dependencies between objects. This type of graph ensures there are no circular dependencies between objects which cause call stack overflows and other unexpected bugs."]})}),"\n",(0,s.jsx)(n.h2,{id:"specifying-relationships-between-dependencies",children:"Specifying relationships between dependencies"}),"\n",(0,s.jsx)(n.p,{children:"Some of the services defined in your graphs may be independent, meaning they don't require any dependencies to be constructed. However, most of the time, services will require other services to perform their responsibilities. In these cases, you can specify the dependencies of a service as arguments in the provider and Obsidian will resolve them automatically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A graph that provides a service that depends on other services"',children:"import {singleton, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@singleton() @graph()\nexport class ApplicationGraph extends ObjectGraph {\n  @provides()\n  httpClient(): HttpClient {\n    return new HttpClient();\n  }\n\n  @provides()\n  databaseService(): DatabaseService {\n    return new DatabaseService();\n  }\n\n  @provides()\n  appInitializer(httpClient: HttpClient, databaseService: DatabaseService): AppInitializer {\n    return new AppInitializer(httpClient, databaseService);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Providers are evaluated lazily. This means that a provider is evaluated only when the dependency it provides is requested. Dependencies that are not used in the application, will never be constructed."})}),"\n",(0,s.jsx)(n.h2,{id:"graph-types",children:"Graph types"}),"\n",(0,s.jsx)(n.p,{children:"There are two types of graphs in Obsidian: A singleton graph and a lifecycle-bound graph."}),"\n",(0,s.jsx)(n.h3,{id:"the-singleton-graph",children:"The singleton graph"}),"\n",(0,s.jsxs)(n.p,{children:["Applications typically have at least one singleton graph. These graphs are used to provide dependencies that are used throughout the application. These dependencies are usually singletons, which means they should only be constructed once. The ",(0,s.jsx)(n.code,{children:"ApplicationGraph"})," in the ",(0,s.jsx)(n.a,{href:"/docs/documentation/usage/Graphs#specifying-relationships-between-dependencies",children:"example above"})," is a singleton graph."]}),"\n",(0,s.jsxs)(n.p,{children:["To declare a singleton graph, annotate the graph class with the ",(0,s.jsx)(n.code,{children:"@singleton"})," decorator."]}),"\n",(0,s.jsx)(n.h3,{id:"the-lifecycle-bound-graph",children:"The lifecycle-bound graph"}),"\n",(0,s.jsx)(n.p,{children:"Lifecycle-bound graphs are used to provide dependencies that are shared between components and hooks in a specific UI scope."}),"\n",(0,s.jsx)(n.p,{children:"Obsidian supports injecting two types of UI scopes:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feature scope (default)"}),": A feature scope is a scope that is shared between multiple screens. For example, a user authentication flow might consist of multiple screens that share the same dependencies. In this case, you can use a lifecycle-bound graph to provide the dependencies for the entire flow. When declaring a feature-scoped graph, a single instance of the graph is created and shared between all the components and hooks that request it."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A feature-scoped lifecycle-bound graph"',children:"import {lifecycleBound, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@lifecycleBound({scope: 'feature'}) @graph()\nclass AuthGraph extends ObjectGraph {\n  @provides()\n  userService(): UserService {\n    return new UserService();\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component scope"}),": A component scope is a scope that is shared between a component and its children. For example, a form component might have multiple input fields that share the same dependencies. In this case, you can use a component-scoped lifecycle-bound graph to provide the dependencies for the form."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A component-scoped lifecycle-bound graph"',children:"import {lifecycleBound, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@lifecycleBound({scope: 'component'}) @graph()\nclass FormGraph extends ObjectGraph {\n  @provides()\n  validationService(): ValidationService {\n    return new ValidationService();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Lifecycle-bound graphs are feature-scoped by default."})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom scope"}),": A custom scope is a special case of a feature scope. When multiple ",(0,s.jsx)(n.code,{children:"@lifecycleBound"})," graphs share the same custom scope, they are considered to be part of the same UI scope. When a custom scoped graph is requested, Obsidian will create all the subgraphs in the same UI scope and destroy them when the last component or hook that requested them is unmounted."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A custom-scoped lifecycle-bound graph"',children:"import {lifecycleBound, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@lifecycleBound({scope: 'AppScope'}) @graph({subgraphs: [ScreenGraph]})\nclass HomeScreenGraph extends ObjectGraph {\n  constructor(private props: HomeScreenProps & BaseProps) {\n    super(props);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A custom-scoped lifecycle-bound subgraph"',children:"@lifecycleBound({scope: 'AppScope'}) @graph()\nclass ScreenGraph extends ObjectGraph {\n  constructor(private props: BaseProps) {\n    super(props);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"The differences between a feature-scoped graph and a custom-scoped graph:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"By default, subgraphs are instantiated lazily. Custom-scoped subgraphs are instantiated immediately when a parent graph with the same scope is instantiated."}),"\n",(0,s.jsx)(n.li,{children:"When instantiated, custom-scoped subgraphs receive the props of the custom-scoped graph that triggered their instantiation."}),"\n",(0,s.jsx)(n.li,{children:"Custom-scoped subgraphs can only be instantiated from a lifecycle bound graph with the same scope."}),"\n"]})]}),"\n",(0,s.jsx)(n.h4,{id:"passing-props-to-a-lifecycle-bound-graph",children:"Passing props to a lifecycle-bound graph"}),"\n",(0,s.jsxs)(n.p,{children:["When a graph is created, it receives the props of the component or hook that requested it. This means that the graph can use the props to construct the dependencies it provides. The ",(0,s.jsx)(n.code,{children:"@lifecycleBound"})," in the example below graph provides a ",(0,s.jsx)(n.code,{children:"userService"})," which requires a ",(0,s.jsx)(n.code,{children:"userId"}),". The ",(0,s.jsx)(n.code,{children:"userId"})," is obtained from props."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="A lifecycle-bound graph"',children:"import {lifecycleBound, graph, ObjectGraph, provides} from 'react-obsidian';\n\ntype HomeScreenProps {\n  userId: string;\n}\n\n@lifecycleBound() @graph()\nclass HomeGraph extends ObjectGraph<HomeScreenProps> {\n  private userId: string;\n\n  construct(props: HomeScreenProps) {\n    super(props);\n    this.userId = props.userId;\n  }\n\n  @provides()\n  userService(): UserService {\n    return new UserService(this.userId);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"the-lifecycle-of-a-lifecycle-bound-graph",children:"The lifecycle of a lifecycle-bound graph"}),"\n",(0,s.jsx)(n.p,{children:"Lifecycle-bound graphs are created when they are requested and are destroyed when the last component or hook that requested them is unmounted. This means that the dependencies provided by a lifecycle-bound graph are shared between components and hooks within the same UI scope and are destroyed when the UI scope is destroyed."}),"\n",(0,s.jsx)(n.h2,{id:"graph-composition",children:"Graph composition"}),"\n",(0,s.jsx)(n.p,{children:"Graph composition is a powerful feature that allows you to create complex dependency graphs by combining smaller graphs. Composing graphs is useful when you want to reuse a graph in multiple places. For example, you might have a singleton graph that provides application-level dependencies. You might also have a lifecycle-bound graph that provides dependencies for a specific UI flow. You can compose these graphs together so that the lifecycle-bound graph can also inject the dependencies provided by the singleton graph."}),"\n",(0,s.jsx)(n.h3,{id:"subgraphs",children:"Subgraphs"}),"\n",(0,s.jsxs)(n.p,{children:["The most common method to compose graphs is to pass a ",(0,s.jsx)(n.code,{children:"subgraphs"})," array to the ",(0,s.jsx)(n.code,{children:"@graph"})," decorator. The ",(0,s.jsx)(n.code,{children:"subgraphs"}),' array contains the graphs you want to "include" in your graph.']}),"\n",(0,s.jsxs)(n.p,{children:["In the example below we declared a lifecycle-bound graph called ",(0,s.jsx)(n.code,{children:"LoginGraph"}),". This graph provides a single dependency called ",(0,s.jsx)(n.code,{children:"loginService"})," which has a dependency on ",(0,s.jsx)(n.code,{children:"httpClient"}),". Since ",(0,s.jsx)(n.code,{children:"httpClient"})," is exposed via the ",(0,s.jsx)(n.code,{children:"ApplicationGraph"}),", we included it in the ",(0,s.jsx)(n.code,{children:"subgraphs"})," array of our graph."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="LoginGraph.ts"',children:"import {graph, ObjectGraph, provides} from 'react-obsidian';\nimport {ApplicationGraph} from './ApplicationGraph';\n\n@lifecycleBound() @graph({subgraphs: [ApplicationGraph]}) \nexport class LoginGraph extends ObjectGraph {\n  @provides()\n  loginService(httpClient: HttpClient): LoginService {\n    return new LoginService(httpClient);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"private-subgraphs",children:"Private subgraphs"}),"\n",(0,s.jsx)(n.p,{children:"Private subgraphs allow you to control the visibility of dependencies when composing graphs. Dependencies from private subgraphs can be used internally within the parent graph's provider methods, but are not exposed to external consumers of that graph."}),"\n",(0,s.jsx)(n.p,{children:"This is useful when you want to encapsulate implementation details and prevent consumers from depending on internal infrastructure."}),"\n",(0,s.jsx)(n.h4,{id:"use-case",children:"Use case"}),"\n",(0,s.jsx)(n.p,{children:"Consider an authentication graph that needs low-level infrastructure services like HTTP clients and configuration, but you don't want to expose these implementation details to consumers of the authentication graph."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(o.A,{value:"AuthGraph",label:"AuthGraph",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="AuthGraph.ts"',children:"import {singleton, graph, ObjectGraph, provides} from 'react-obsidian';\nimport {LoggingGraph} from './LoggingGraph';\nimport {InfrastructureGraph} from './InfrastructureGraph';\n\n@singleton() @graph({\n  subgraphs: [LoggingGraph],           // Public - exposed to consumers\n  privateSubgraphs: [InfrastructureGraph]  // Private - internal use only\n})\nexport class AuthGraph extends ObjectGraph {\n  @provides()\n  authService(httpClient: HttpClient, logger: Logger): AuthService {\n    // Both httpClient (from private) and logger (from public) can be used here\n    return new AuthService(httpClient, logger);\n  }\n}\n"})})}),(0,s.jsx)(o.A,{value:"LoggingGraph",label:"LoggingGraph",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="LoggingGraph.ts"',children:"import {singleton, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@singleton() @graph()\nexport class LoggingGraph extends ObjectGraph {\n  @provides()\n  logger(): Logger {\n    return new Logger();\n  }\n}\n"})})}),(0,s.jsx)(o.A,{value:"InfrastructureGraph",label:"InfrastructureGraph",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="InfrastructureGraph.ts"',children:"import {singleton, graph, ObjectGraph, provides} from 'react-obsidian';\n\n@singleton() @graph()\nexport class InfrastructureGraph extends ObjectGraph {\n  @provides()\n  httpClient(): HttpClient {\n    return new HttpClient();\n  }\n}\n"})})})]}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"AuthGraph"})," can use both ",(0,s.jsx)(n.code,{children:"httpClient"})," (from ",(0,s.jsx)(n.code,{children:"InfrastructureGraph"}),") and ",(0,s.jsx)(n.code,{children:"logger"})," (from ",(0,s.jsx)(n.code,{children:"LoggingGraph"}),") in its provider methods"]}),"\n",(0,s.jsxs)(n.li,{children:["Consumers of ",(0,s.jsx)(n.code,{children:"AuthGraph"})," can access ",(0,s.jsx)(n.code,{children:"logger"})," and ",(0,s.jsx)(n.code,{children:"authService"}),", but ",(0,s.jsx)(n.strong,{children:"cannot"})," access ",(0,s.jsx)(n.code,{children:"httpClient"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"visibility-rules",children:"Visibility rules"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Public subgraphs"}),": Dependencies are accessible both internally (within the graph's providers) and externally (to consumers via injection or ",(0,s.jsx)(n.code,{children:"Obsidian.obtain()"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Private subgraphs"}),": Dependencies are accessible only internally (within the graph's providers)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transitive dependencies"}),": If a private subgraph has its own subgraphs, those transitive dependencies are also accessible internally"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"abstract-graphs",children:"Abstract graphs"}),"\n",(0,s.jsx)(n.p,{children:"Abstract graphs are graphs that are not instantiated directly. Instead, they are used as a base for other graphs. Abstract graphs are useful when you want to define a set of dependencies that are shared between multiple graphs."}),"\n",(0,s.jsxs)(n.p,{children:["In the example below we declared an abstract graph called ",(0,s.jsx)(n.code,{children:"ScreenGraph"}),". This graph provides a single dependency called ",(0,s.jsx)(n.code,{children:"screenLogger"})," which is used to log messages from the screen. We want to show the name of the screen in the log messages, so the ",(0,s.jsx)(n.code,{children:"ScreenLogger"})," requires the name of the screen as a constructor argument."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"screenName"})," provider method is marked as ",(0,s.jsx)(n.code,{children:"abstract"})," which means that it must be implemented by the parent class. This allows us to create multiple graphs that extend the ",(0,s.jsx)(n.code,{children:"ScreenGraph"})," and provide the screen name."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="AbstractGraph.ts"',children:"import {graph, ObjectGraph, provides} from 'react-obsidian';\n\nexport abstract class ScreenGraph extends ObjectGraph {\n  @provides()\n  screenLogger(screenName: string) {\n    return new ScreenLogger(screenName);\n  }\n\n  // highlight-next-line\n  abstract screenName(): string; // This method must be implemented by the parent graphs\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following two graphs extend the base ",(0,s.jsx)(n.code,{children:"ScreenGraph"}),". Each graph provides a different screen name and a service that is specific to that screen."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(o.A,{value:"HomeGraph",label:"HomeGraph",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="HomeGraph.ts"',children:"import {graph, ObjectGraph, provides} from 'react-obsidian';\n\n@graph()\nexport class HomeGraph extends ScreenGraph {\n  @provides()\n  override screenName() {\n    return 'HomeScreen';\n  }\n\n  @provides()\n  homeService(screenLogger: ScreenLogger): HomeService {\n    return new HomeService(screenLogger);\n  }\n}\n"})})}),(0,s.jsx)(o.A,{value:"ProfileGraph",label:"ProfileGraph",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="ProfileGraph.ts"',children:"import {graph, ObjectGraph, provides} from 'react-obsidian';\n\n@graph()\nexport class ProfileGraph extends ScreenGraph {\n  @provides()\n  override screenName() {\n    return 'ProfileScreen';\n  }\n\n  @provides()\n  profileService(screenLogger: ScreenLogger): ProfileService {\n    return new ProfileService(screenLogger);\n  }\n}\n"})})})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Because abstract graphs aren't instantiated directly, they don't need to be annotated with the ",(0,s.jsx)(n.code,{children:"@graph"})," decorator. Abstract providers aren't annotated with the ",(0,s.jsx)(n.code,{children:"@provides"})," decorator for the same reason."]})}),"\n",(0,s.jsx)(n.h2,{id:"typed-dependencies",children:"Typed dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"DependenciesOf"})," utility type creates a new type consisting the dependencies provided by a graph. This type can be used to type the dependencies of hooks or props required by components. This utility type takes two arguments: the graph and a union of the keys of the dependencies we want to inject."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example we create a type called ",(0,s.jsx)(n.code,{children:"ApplicationDependencies"})," which contains the dependencies ",(0,s.jsx)(n.code,{children:"httpClient"})," and ",(0,s.jsx)(n.code,{children:"databaseService"})," from the ",(0,s.jsx)(n.code,{children:"ApplicationGraph"})," graph."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// {httpClient: HttpClient, databaseService: DatabaseService}\ntype Dependencies = DependenciesOf<ApplicationGraph, 'httpClient' | 'databaseService'>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In cases where a graph has subgraphs, we can pass an array of graphs to the ",(0,s.jsx)(n.code,{children:"DependenciesOf"})," utility type to create a type that contains the dependencies from all the graphs. Using the ",(0,s.jsx)(n.code,{children:"LoginGraph"})," from the example above, we create a type that contains dependencies from both the ",(0,s.jsx)(n.code,{children:"LoginGraph"})," and the ",(0,s.jsx)(n.code,{children:"ApplicationGraph"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// {httpClient: HttpClient, loginService: LoginService}\ntype Dependencies = DependenciesOf<[LoginGraph, ApplicationGraph], 'httpClient' | 'loginService'>;\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},6816:(e,n,r)=>{r.d(n,{A:()=>i});r(4041);var t=r(3640);const s={tabItem:"tabItem_OMyP"};var a=r(1085);function i(e){let{children:n,hidden:r,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,i),hidden:r,children:n})}}}]);