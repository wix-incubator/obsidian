"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7963],{4693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var i=t(1085),s=t(1184);const a={sidebar_position:5,title:"Classes"},o=void 0,c={id:"documentation/usage/Classes",title:"Classes",description:"Injecting classes",source:"@site/docs/documentation/usage/Classes.mdx",sourceDirName:"documentation/usage",slug:"/documentation/usage/Classes",permalink:"/obsidian/docs/documentation/usage/Classes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/usage/Classes.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Classes"},sidebar:"docs2",previous:{title:"Class components",permalink:"/obsidian/docs/documentation/usage/ClassComponents"},next:{title:"Reactivity",permalink:"/obsidian/docs/documentation/usage/Reactivity"}},r={},l=[{value:"Injecting classes",id:"injecting-classes",level:2},{value:"Delayed injection",id:"delayed-injection",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"injecting-classes",children:"Injecting classes"}),"\n",(0,i.jsxs)(n.p,{children:["Injecting classes is a two step process. First, annotate the class with the ",(0,i.jsx)(n.code,{children:"@injectable"})," annotation and pass the graph from which dependencies should be resolve. Then, declare the dependencies as class members and annotate them with the ",(0,i.jsx)(n.code,{children:"@inject"})," annotation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {injectable, inject} from 'react-obsidian';\nimport {ApplicationGraph} from './ApplicationGraph';\n\n@injectable(ApplicationGraph)\nexport class MyClass {\n  @inject() private httpClient!: HttpClient;\n  \n}\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"Always prefer constructor injection over field injection",type:"important",children:(0,i.jsxs)(n.p,{children:["Constructor injection is the preferred way to inject dependencies. It is more explicit and easier to test. ",(0,i.jsx)(n.strong,{children:"Field injection should only be used when a class is not instantiated by a graph."})]})}),"\n",(0,i.jsx)(n.h2,{id:"delayed-injection",children:"Delayed injection"}),"\n",(0,i.jsxs)(n.p,{children:["Dependencies annotated with the ",(0,i.jsx)(n.code,{children:"@inject"})," annotation are resolved immediately ",(0,i.jsx)(n.strong,{children:"after"})," the constructor is called. If you want to inject a class at a later point in time, you can use the ",(0,i.jsx)(n.code,{children:"@lateInject"})," annotation instead, and inject the dependencies by manually with the ",(0,i.jsx)(n.code,{children:"Obsidian.inject()"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {injectable, lateInject} from 'react-obsidian';\nimport {ApplicationGraph} from './ApplicationGraph';\n\n@injectable(ApplicationGraph)\nexport class MyClass {\n  @lateInject() private httpClient!: HttpClient;\n\n  public init() {\n    console.log(this.httpClient === undefined); // true\n    Obsidian.inject(this);\n    console.log(this.httpClient === undefined); // false\n  }\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var i=t(4041);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);