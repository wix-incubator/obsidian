"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8817],{7246:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=n(9575),r=(n(4041),n(2247));const a={sidebar_position:3,title:"MVVM architecture with Obsidian"},i=void 0,l={unversionedId:"guides/mvv",id:"guides/mvv",title:"MVVM architecture with Obsidian",description:"MVVM (Model-View-ViewModel) is a software architecture widely used in modern front-end development. It emphasizes separation of concerns and improves code structure. In the Model-View-ViewModel pattern, code is organized into three layers:",source:"@site/docs/guides/mvv.mdx",sourceDirName:"guides",slug:"/guides/mvv",permalink:"/obsidian/docs/guides/mvv",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/mvv.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"MVVM architecture with Obsidian"},sidebar:"guides",previous:{title:"Configurable applications",permalink:"/obsidian/docs/guides/configurableApplications"}},s={},c=[{value:"Implementation",id:"implementation",level:2},{value:"Step 1: Create the model",id:"step-1-create-the-model",level:2},{value:"Step 2: Create the ViewModel",id:"step-2-create-the-viewmodel",level:2},{value:"Step 3: Create the View",id:"step-3-create-the-view",level:2},{value:"Step 4: Create the Graph",id:"step-4-create-the-graph",level:2},{value:"Wrapping up",id:"wrapping-up",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(d,(0,o.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"MVVM (Model-View-ViewModel) is a software architecture widely used in modern front-end development. It emphasizes separation of concerns and improves code structure. In the Model-View-ViewModel pattern, code is organized into three layers:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The Model represents the data and business logic."),(0,r.yg)("li",{parentName:"ul"},"The View handles UI rendering and user interactions."),(0,r.yg)("li",{parentName:"ul"},"The ViewModel acts as an intermediary between the Model and the View. It exposes data and commands to the View, and allows for two-way communication between the Model and the View.")),(0,r.yg)("p",null,"This decoupling results in code that's easier to test and maintain."),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"In this article you'll learn:"),(0,r.yg)("ol",{parentName:"admonition"},(0,r.yg)("li",{parentName:"ol"},"How to structure a single UI component using MVVM architecture"),(0,r.yg)("li",{parentName:"ol"},"How to connect the layers together using Obsidian"))),(0,r.yg)("h2",{id:"implementation"},"Implementation"),(0,r.yg)("p",null,"We'll refactor a basic counter application to use MVVM architecture. The application has a button that increments a counter, and an input field that displays the counter value.\nThe original implementation uses hooks to manage the state and handle user interactions. Our aim in this refactor is to decouple the counter logic from the view into a separate class. For the sake of simplicity we chose a minimal example so we can focus on the architecture and the relationships between the layers."),(0,r.yg)("p",null,"This is the original implementation of the counter component:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="Counter.tsx"',title:'"Counter.tsx"'},'const Counter = () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <input readOnly type="text" value={count} />\n    </div>\n  );\n};\n')),(0,r.yg)("h2",{id:"step-1-create-the-model"},"Step 1: Create the model"),(0,r.yg)("p",null,"The model represents the data and business logic of the application. In our case, the model has a single property ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," and a method ",(0,r.yg)("inlineCode",{parentName:"p"},"increment()")," that increments the counter."),(0,r.yg)("p",null,"Notice that the ",(0,r.yg)("inlineCode",{parentName:"p"},"count")," property is defined as an ",(0,r.yg)("inlineCode",{parentName:"p"},"Observable"),". This is necessary to make the property reactive. The ViewModel will re-render the view whenever the count value changes."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="CounterModel.ts"',title:'"CounterModel.ts"'},"export class CounterModel {\n  public readonly count = new Observable(0);\n\n  public increment() {\n    this.count.value++;\n  }\n}\n")),(0,r.yg)("h2",{id:"step-2-create-the-viewmodel"},"Step 2: Create the ViewModel"),(0,r.yg)("p",null,"The ViewModel mediates between the Model and the View. Unlike the model which contains data for an entire domain, the View Model contains a subset of that data that's relevant to a specific view. Our View Model exposes the current count value and the ",(0,r.yg)("inlineCode",{parentName:"p"},"onIncrementClick")," method to the View."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="CounterViewModel.ts"',title:'"CounterViewModel.ts"'},'import { useObserver } from "react-obsidian"\n\nexport const useCounterViewModel = (model: CounterModel) => {\n  const [count] = useObserver(model.count);\n\n  return {\n    count,\n    onIncrementClick: () => model.increment(),\n  };\n}\n')),(0,r.yg)("h2",{id:"step-3-create-the-view"},"Step 3: Create the View"),(0,r.yg)("p",null," The view is responsible for rendering the UI. Let's refactor the original counter component to use the ViewModel. Our aim is to decouple the count logic from the view. It doesn't need to know how the count is incremented or where the count value comes from."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="Counter.tsx"',title:'"Counter.tsx"'},"import {CounterGraph} from './CounterGraph';\n\n// the viewModel hook is injected by the CounterGraph\nconst _Counter = ({useViewModel}: DependenciesOf<CounterGraph, 'useViewModel'>) => {\n  const {count, increment} = useViewModel();\n\n  return (\n    <div>\n      <button onClick={increment}>Increment</button>\n      <input readOnly type=\"text\" value={vm.count} />\n    </div>\n  );\n};\n\nexport const Counter = injectComponent(_Counter, CounterGraph);\n")),(0,r.yg)("h2",{id:"step-4-create-the-graph"},"Step 4: Create the Graph"),(0,r.yg)("p",null,"At this point we have our Model, View, and View Model written. However, we still need to connect them to one another. We can do this by creating a graph."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="CounterGraph.ts"',title:'"CounterGraph.ts"'},'import { Graph, ObjectGraph, Provides } from "react-obsidian";\n\n@Singleton() @Graph()\nexport class CounterGraph {\n  @Provides()\n  model(): CounterModel {\n    return new CounterModel();\n  }\n\n // The useViewModel hook is instantiated once and injected into the Counter component\n  @Provides()\n  useViewModel(model: CounterModel) {\n    return () => useCounterViewModel(model);\n  }\n}\n')),(0,r.yg)("h2",{id:"wrapping-up"},"Wrapping up"),(0,r.yg)("p",null,"We've successfully refactored the counter component to use MVVM architecture."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Our view is now decoupled from the counter logic,"),(0,r.yg)("li",{parentName:"ul"},"The ViewModel exposes the data and commands to the view,"),(0,r.yg)("li",{parentName:"ul"},"The Model contains reactive data and business logic.")),(0,r.yg)("p",null,"We hope this article helped you understand how to use MVVM architecture with Obsidian. You can find a more fleshed out example in the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/guyca/obsidian-tic-tac-toe"},"obsidian-tic-tac-toe")," repository. If you have any questions or feedback, please reach out to us on ",(0,r.yg)("a",{parentName:"p",href:"https://discord.gg/MDH2axwaPy"},"Discord"),". We'd love to hear from you!"))}p.isMDXComponent=!0},2247:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>m});var o=n(4041);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||a;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);