"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[741],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=o.createContext({}),p=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},l=function(e){var n=p(e.components);return o.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?o.createElement(h,a(a({ref:n},l),{},{components:t})):o.createElement(h,a({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=d;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var p=2;p<i;p++)a[p]=t[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1718:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var o=t(7462),r=(t(7294),t(3905));const i={sidebar_position:2},a=void 0,c={unversionedId:"usage/Hooks",id:"usage/Hooks",title:"Hooks",description:"Injecting hooks",source:"@site/docs/usage/Hooks.mdx",sourceDirName:"usage",slug:"/usage/Hooks",permalink:"/docs/usage/Hooks",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usage/Hooks.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Graphs",permalink:"/docs/usage/Graphs"},next:{title:"Functional components",permalink:"/docs/usage/FunctionalComponents"}},s={},p=[{value:"Injecting hooks",id:"injecting-hooks",level:2},{value:"Strongly typed hooks",id:"strongly-typed-hooks",level:2},{value:"Combining injected dependencies and required arguments",id:"combining-injected-dependencies-and-required-arguments",level:3},{value:"Typing the return value of a hook",id:"typing-the-return-value-of-a-hook",level:3}],l={toc:p};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"injecting-hooks"},"Injecting hooks"),(0,r.kt)("p",null,"Hooks are a fundamental construct in React. They allow you to plug into the lifecycle of a component or react to user interaction and execute code accordingly. As such, hooks typically need to interact with services where the actual logic is implemented."),(0,r.kt)("p",null,"Injecting hooks is simple and straightforward. Simply wrap your hook with the ",(0,r.kt)("inlineCode",{parentName:"p"},"injectHook")," function and declare any required dependencies as destructured properties."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\nconst myHook = ({fooService, barService}: Props) => {\n  // do something with fooService and barService\n}\n\ntype Props = DependenciesOf<ApplicationGraph, 'fooService' | 'barService'>; // {fooService: FooService, barService: BarService}\n\nexport injectHook(myHook, ApplicationGraph);\n")),(0,r.kt)("h2",{id:"strongly-typed-hooks"},"Strongly typed hooks"),(0,r.kt)("p",null,"Writing strongly typed hooks is important to ensure that your hooks are easy to use and that you don't accidentally break them when refactoring. "),(0,r.kt)("h3",{id:"combining-injected-dependencies-and-required-arguments"},"Combining injected dependencies and required arguments"),(0,r.kt)("p",null,"Sometimes you want to inject hooks with dependencies, but also require additional arguments that will be passed from the calling scope. This is possible by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"injectHookWithArguments")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\ntype Injected = DependenciesOf<ApplicationGraph, 'fooService'>; // {fooService: FooService}\ntype Own = {count: number};\n\nconst myHook = ({fooService, count}: Injected & Own) => {\n  // do something with fooService and count\n}\n\nexport default injectHookWithArguments<Injected, Own>(myHook, ApplicationGraph);\n")),(0,r.kt)("p",null,"When using ",(0,r.kt)("inlineCode",{parentName:"p"},"myHook"),", we must pass the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," argument otherwise we will get a type error. ",(0,r.kt)("inlineCode",{parentName:"p"},"fooService"),", on the other hand, is optional and will be injected from the graph unless passed explicitly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import myHook from './myHook';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(1337);\n  myHook({count}); \n  \n}\n")),(0,r.kt)("h3",{id:"typing-the-return-value-of-a-hook"},"Typing the return value of a hook"),(0,r.kt)("p",null,"When using the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"injectHook")," function, the return value of the hook is inferred automatically by TypeScript. However, when using ",(0,r.kt)("inlineCode",{parentName:"p"},"injectHookWithArguments"),", due to limitations of TypeScript's Generics system, the return value is not inferred and you'll have to specify it explicity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectHook, DependenciesOf } from 'react-obsidian';\nimport { ApplicationGraph } from './ApplicationGraph';\n\ntype Injected = DependenciesOf<ApplicationGraph, 'fooService'>;\ntype Own = {count: number};\ntype Result: {onPress: () => void};\n\nconst myHook = ({fooService, count}: Injected & Own): Result => {\n  const onPress = useCallback(() => {\n    fooService.doSomething(count);\n  }, [fooService, count]);\n  return {onPress};\n}\n\nexport default injectHookWithArguments<Injected, Own, Result>(myHook, ApplicationGraph);\n")),(0,r.kt)("p",null,"Now the onPress callback is typed correctly when using the injected hook."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import myHook from './myHook';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(1337);\n  const {onPress} = myHook({count});\n}\n")))}u.isMDXComponent=!0}}]);