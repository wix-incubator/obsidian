"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7963],{1184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(4041);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},7443:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"documentation/usage/Classes","title":"Classes","description":"Injecting classes","source":"@site/docs/documentation/usage/Classes.mdx","sourceDirName":"documentation/usage","slug":"/documentation/usage/Classes","permalink":"/obsidian/docs/documentation/usage/Classes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/documentation/usage/Classes.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Classes"},"sidebar":"docs2","previous":{"title":"Class components","permalink":"/obsidian/docs/documentation/usage/ClassComponents"},"next":{"title":"Reactivity","permalink":"/obsidian/docs/documentation/usage/Reactivity"}}');var i=t(1085),a=t(1184);const o={sidebar_position:5,title:"Classes"},c=void 0,r={},l=[{value:"Injecting classes",id:"injecting-classes",level:2},{value:"Delayed injection",id:"delayed-injection",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"injecting-classes",children:"Injecting classes"}),"\n",(0,i.jsxs)(n.p,{children:["Injecting classes is a two step process. First, annotate the class with the ",(0,i.jsx)(n.code,{children:"@injectable"})," annotation and pass the graph from which dependencies should be resolve. Then, declare the dependencies as class members and annotate them with the ",(0,i.jsx)(n.code,{children:"@inject"})," annotation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {injectable, inject} from 'react-obsidian';\nimport {ApplicationGraph} from './ApplicationGraph';\n\n@injectable(ApplicationGraph)\nexport class MyClass {\n  @inject() private httpClient!: HttpClient;\n  \n}\n"})}),"\n",(0,i.jsx)(n.admonition,{title:"Always prefer constructor injection over field injection",type:"important",children:(0,i.jsxs)(n.p,{children:["Constructor injection is the preferred way to inject dependencies. It is more explicit and easier to test. ",(0,i.jsx)(n.strong,{children:"Field injection should only be used when a class is not instantiated by a graph."})]})}),"\n",(0,i.jsx)(n.h2,{id:"delayed-injection",children:"Delayed injection"}),"\n",(0,i.jsxs)(n.p,{children:["Dependencies annotated with the ",(0,i.jsx)(n.code,{children:"@inject"})," annotation are resolved immediately ",(0,i.jsx)(n.strong,{children:"after"})," the constructor is called. If you want to inject a class at a later point in time, you can use the ",(0,i.jsx)(n.code,{children:"@lateInject"})," annotation instead, and inject the dependencies by manually with the ",(0,i.jsx)(n.code,{children:"Obsidian.inject()"})," function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {injectable, lateInject} from 'react-obsidian';\nimport {ApplicationGraph} from './ApplicationGraph';\n\n@injectable(ApplicationGraph)\nexport class MyClass {\n  @lateInject() private httpClient!: HttpClient;\n\n  public init() {\n    console.log(this.httpClient === undefined); // true\n    Obsidian.inject(this);\n    console.log(this.httpClient === undefined); // false\n  }\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);