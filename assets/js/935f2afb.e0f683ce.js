"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Introduction","href":"/obsidian/docs/documentation","docId":"documentation"},{"type":"link","label":"Installation","href":"/obsidian/docs/installation","docId":"installation"},{"type":"category","label":"Usage","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Graphs","href":"/obsidian/docs/usage/Graphs","docId":"usage/Graphs"},{"type":"link","label":"Hooks","href":"/obsidian/docs/usage/Hooks","docId":"usage/Hooks"},{"type":"link","label":"Functional components","href":"/obsidian/docs/usage/FunctionalComponents","docId":"usage/FunctionalComponents"},{"type":"link","label":"Class components","href":"/obsidian/docs/usage/ClassComponents","docId":"usage/ClassComponents"},{"type":"link","label":"Classes","href":"/obsidian/docs/usage/Classes","docId":"usage/Classes"},{"type":"link","label":"Service locator","href":"/obsidian/docs/usage/ServiceLocator","docId":"usage/ServiceLocator"}],"href":"/obsidian/docs/category/usage"},{"type":"category","label":"meta","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Graph middlewares","href":"/obsidian/docs/meta/middlewares","docId":"meta/middlewares"},{"type":"link","label":"Clearing graphs","href":"/obsidian/docs/meta/clearingGraphs","docId":"meta/clearingGraphs"}]}]},"docs":{"documentation":{"id":"documentation","title":"Introduction","description":"Obsidian is a dependency injection container with first-class support for React and React Native applications.","sidebar":"tutorialSidebar"},"installation":{"id":"installation","title":"Installation","description":"Like most Dependency Injection frameworks, Obsidian uses automatic code generation to create the bindings necessary for resolving dependencies. This approach helps reduce the amount of boilerplate code required by developers. Obsidian relies on Babel for code generation, so you\'ll need to have Babel configured in your project.","sidebar":"tutorialSidebar"},"meta/clearingGraphs":{"id":"meta/clearingGraphs","title":"Clearing graphs","description":"Graphs can be cleared by invoking the Obsidian.clearGraphs() function. This is useful in tests or when you need to reset the system to it\'s original state, for example after a user logs out.","sidebar":"tutorialSidebar"},"meta/middlewares":{"id":"meta/middlewares","title":"Graph middlewares","description":"Graph middlewares let you plug into the graph creation process and modify the graph in any way you want. This is useful when working on large scale applications where \\"observability\\" is a key concern. For example, you can use a middleware to swizzle providers, add logging, or even add a new provider to the graph.","sidebar":"tutorialSidebar"},"usage/ClassComponents":{"id":"usage/ClassComponents","title":"Class components","description":"Injecting class components","sidebar":"tutorialSidebar"},"usage/Classes":{"id":"usage/Classes","title":"Classes","description":"Injecting classes","sidebar":"tutorialSidebar"},"usage/FunctionalComponents":{"id":"usage/FunctionalComponents","title":"Functional components","description":"Injecting functional components","sidebar":"tutorialSidebar"},"usage/Graphs":{"id":"usage/Graphs","title":"Graphs","description":"Introduction","sidebar":"tutorialSidebar"},"usage/Hooks":{"id":"usage/Hooks","title":"Hooks","description":"Injecting hooks","sidebar":"tutorialSidebar"},"usage/ServiceLocator":{"id":"usage/ServiceLocator","title":"Service locator","description":"Obtaining dependencies imperatively","sidebar":"tutorialSidebar"}}}')}}]);