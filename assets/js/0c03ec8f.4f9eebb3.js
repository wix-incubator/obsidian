"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[6437],{356:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs2":[{"type":"link","label":"Introduction","href":"/obsidian/docs/documentation/","docId":"documentation/documentation","unlisted":false},{"type":"link","label":"Installation","href":"/obsidian/docs/documentation/installation","docId":"documentation/installation","unlisted":false},{"type":"category","label":"Usage","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Graphs","href":"/obsidian/docs/documentation/usage/Graphs","docId":"documentation/usage/Graphs","unlisted":false},{"type":"link","label":"Hooks","href":"/obsidian/docs/documentation/usage/Hooks","docId":"documentation/usage/Hooks","unlisted":false},{"type":"link","label":"Functional components","href":"/obsidian/docs/documentation/usage/FunctionalComponents","docId":"documentation/usage/FunctionalComponents","unlisted":false},{"type":"link","label":"Class components","href":"/obsidian/docs/documentation/usage/ClassComponents","docId":"documentation/usage/ClassComponents","unlisted":false},{"type":"link","label":"Classes","href":"/obsidian/docs/documentation/usage/Classes","docId":"documentation/usage/Classes","unlisted":false},{"type":"link","label":"Reactivity","href":"/obsidian/docs/documentation/usage/Reactivity","docId":"documentation/usage/Reactivity","unlisted":false},{"type":"link","label":"Service locator","href":"/obsidian/docs/documentation/usage/ServiceLocator","docId":"documentation/usage/ServiceLocator","unlisted":false}],"href":"/obsidian/docs/category/usage"},{"type":"category","label":"Meta","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"ESLint plugin","href":"/obsidian/docs/documentation/meta/eslint","docId":"documentation/meta/eslint","unlisted":false},{"type":"link","label":"Clearing graphs","href":"/obsidian/docs/documentation/meta/clearingGraphs","docId":"documentation/meta/clearingGraphs","unlisted":false},{"type":"link","label":"Graph middlewares","href":"/obsidian/docs/documentation/meta/middlewares","docId":"documentation/meta/middlewares","unlisted":false}],"href":"/obsidian/docs/category/meta"}],"reference":[{"type":"link","label":"Obsidian","href":"/obsidian/docs/reference/obsidian","docId":"reference/obsidian","unlisted":false},{"type":"link","label":"Observable","href":"/obsidian/docs/reference/observable","docId":"reference/observable","unlisted":false},{"type":"link","label":"MediatorObservable","href":"/obsidian/docs/reference/mediatorObservable","docId":"reference/mediatorObservable","unlisted":false},{"type":"link","label":"useObserver","href":"/obsidian/docs/reference/useObserver","docId":"reference/useObserver","unlisted":false},{"type":"link","label":"Model","href":"/obsidian/docs/reference/model","docId":"reference/model","unlisted":false},{"type":"link","label":"useObservers","href":"/obsidian/docs/reference/useObservers","docId":"reference/useObservers","unlisted":false},{"type":"category","label":"TestKit","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"mockGraphs","href":"/obsidian/docs/reference/testKit/mockGraphs","docId":"reference/testKit/mockGraphs","unlisted":false},{"type":"link","label":"mockModel","href":"/obsidian/docs/reference/testKit/mockModel","docId":"reference/testKit/mockModel","unlisted":false}],"href":"/obsidian/docs/category/testkit"}],"guides":[{"type":"link","label":"MVVM architecture with Obsidian","href":"/obsidian/docs/guides/mvvm","docId":"guides/mvvm","unlisted":false},{"type":"link","label":" Avoiding prop drilling","href":"/obsidian/docs/guides/avoidingPropDrilling","docId":"guides/avoidingPropDrilling","unlisted":false},{"type":"link","label":"Configurable applications","href":"/obsidian/docs/guides/configurableApplications","docId":"guides/configurableApplications","unlisted":false},{"type":"link","label":"Mocking dependencies in unit tests","href":"/obsidian/docs/guides/mockDependencies","docId":"guides/mockDependencies","unlisted":false}]},"docs":{"documentation/documentation":{"id":"documentation/documentation","title":"Introduction","description":"Obsidian is a dependency injection container with first-class support for React and React Native applications.","sidebar":"docs2"},"documentation/installation":{"id":"documentation/installation","title":"Installation","description":"Like most Dependency Injection frameworks, Obsidian uses automatic code generation to create the bindings necessary for resolving dependencies. This approach helps reduce the amount of boilerplate code required by developers. Obsidian relies on Babel for code generation, so you\'ll need to have Babel configured in your project.","sidebar":"docs2"},"documentation/meta/clearingGraphs":{"id":"documentation/meta/clearingGraphs","title":"Clearing graphs","description":"Graphs can be cleared by invoking the Obsidian.clearGraphs() function. This is useful in tests or when you need to reset the system to it\'s original state, for example after a user logs out.","sidebar":"docs2"},"documentation/meta/eslint":{"id":"documentation/meta/eslint","title":"ESLint plugin","description":"The eslint-plugin-obsidian package provides ESLint rules for Obsidian. These rules help you catch common mistakes and enforce best practices when using Obsidian.","sidebar":"docs2"},"documentation/meta/middlewares":{"id":"documentation/meta/middlewares","title":"Graph middlewares","description":"Graph middlewares let you plug into the graph creation process and modify the graph in any way you want. This is useful when working on large scale applications where \\"observability\\" is a key concern. For example, you can use a middleware to swizzle providers, add logging, or even add a new provider to the graph.","sidebar":"docs2"},"documentation/usage/ClassComponents":{"id":"documentation/usage/ClassComponents","title":"Class components","description":"Injecting class components","sidebar":"docs2"},"documentation/usage/Classes":{"id":"documentation/usage/Classes","title":"Classes","description":"Injecting classes","sidebar":"docs2"},"documentation/usage/FunctionalComponents":{"id":"documentation/usage/FunctionalComponents","title":"Functional components","description":"Injecting functional components","sidebar":"docs2"},"documentation/usage/Graphs":{"id":"documentation/usage/Graphs","title":"Graphs","description":"Introduction","sidebar":"docs2"},"documentation/usage/Hooks":{"id":"documentation/usage/Hooks","title":"Hooks","description":"Injecting hooks","sidebar":"docs2"},"documentation/usage/Reactivity":{"id":"documentation/usage/Reactivity","title":"Reactivity","description":"Obsidian is first and foremost a dependency injection library. But it also includes reactive programming features that allow you to observe changes in your data and react to them. This is useful for things like updating the UI when a value changes.","sidebar":"docs2"},"documentation/usage/ServiceLocator":{"id":"documentation/usage/ServiceLocator","title":"Service locator","description":"Obtaining dependencies imperatively","sidebar":"docs2"},"guides/avoidingPropDrilling":{"id":"guides/avoidingPropDrilling","title":" Avoiding prop drilling","description":"Prop Drilling is a common issue in React development where props are passed down multiple levels of the component hierarchy, making the code difficult to maintain and understand. This guide will show you how to use @LifecycleBound graphs to avoid Prop Drilling.","sidebar":"guides"},"guides/configurableApplications":{"id":"guides/configurableApplications","title":"Configurable applications","description":"Designing applications to be flexible and configurable makes them more tolerable to changing requirements. The ability to change code frequently and quickly is one of the most important KPIs of any development team. This is generally made possible by a design that facilitates small pull requests, that modify a minimal amount of code across a minimal number of files.","sidebar":"guides"},"guides/mockDependencies":{"id":"guides/mockDependencies","title":"Mocking dependencies in unit tests","description":"Tests are an integral part of any software project. They let you verify that your code works as expected and that it doesn\'t break when you make changes. We want our tests to be as clear as possible so that developers don\'t have to waste time figuring out what the test is doing our how to fix it when it fails.","sidebar":"guides"},"guides/mvvm":{"id":"guides/mvvm","title":"MVVM architecture with Obsidian","description":"MVVM (Model-View-ViewModel) is a software architecture widely used in modern front-end development. It emphasizes separation of concerns and improves code structure. In the Model-View-ViewModel pattern, code is organized into three layers:","sidebar":"guides"},"reference/mediatorObservable":{"id":"reference/mediatorObservable","title":"MediatorObservable","description":"MediatorObservable is a type of Observable that acts as an adapter between one or more source Observables. It allows us to create a new observable stream based on the values of other observables.","sidebar":"reference"},"reference/model":{"id":"reference/model","title":"Model","description":"Model is an abstract utility class that provides an easy way to observe specific properties of an object.","sidebar":"reference"},"reference/observable":{"id":"reference/observable","title":"Observable","description":"Observable is a class that represents a stream of values. It is similar to Promise in that it is a container for a value that will be available in the future. However, unlike Promise, Observable can emit multiple values over time.","sidebar":"reference"},"reference/obsidian":{"id":"reference/obsidian","title":"Obsidian","description":"Obsidian exposes a set of functions that allow you to interact with the Obsidian framework imperatively.","sidebar":"reference"},"reference/testKit/mockGraphs":{"id":"reference/testKit/mockGraphs","title":"mockGraphs","description":"mockGraphs is a function that is used in tests to replace the implementation of graphs with a mock implementation.","sidebar":"reference"},"reference/testKit/mockModel":{"id":"reference/testKit/mockModel","title":"mockModel","description":"mockModel is a utility function that allows you to easily mock models.","sidebar":"reference"},"reference/useObserver":{"id":"reference/useObserver","title":"useObserver","description":"useObserver is a Hook that allows you to react to changes in an observable.","sidebar":"reference"},"reference/useObservers":{"id":"reference/useObservers","title":"useObservers","description":"useObservers is a Hook that allows you to react to changes in multiple observables in a single statement.","sidebar":"reference"}}}}')}}]);